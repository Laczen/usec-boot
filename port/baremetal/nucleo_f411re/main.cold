#include <stdint.h>
#include <stddef.h>
#include <stdarg.h>
#include "usecboot.h"
#include "root_pkey.h"

#ifndef container_of
#define container_of(ptr, type, member) ({ \
    const typeof(((type *)0)->member) * __mptr = (ptr); \
    (type *)((char *)__mptr - offsetof(type, member)); })
#endif

#define IMAGE1_BASE 0x00020000
#define IMAGE2_BASE 0x00040000
#define HMAC_KEY "\xab\x23\x45\x56"

#include <stdint.h>

#define PERIPH_BASE        0x40000000UL

#define AHB1PERIPH_BASE    (PERIPH_BASE + 0x00020000UL)
#define APB1PERIPH_BASE    (PERIPH_BASE + 0x00000000UL)

#define RCC_BASE           (AHB1PERIPH_BASE + 0x3800UL)
#define GPIOA_BASE         (AHB1PERIPH_BASE + 0x0000UL)
#define USART2_BASE        (APB1PERIPH_BASE + 0x4400UL)

#define RCC_AHB1ENR        (*(volatile unsigned long *)(RCC_BASE + 0x30))
#define RCC_APB1ENR        (*(volatile unsigned long *)(RCC_BASE + 0x40))

#define GPIOA_MODER        (*(volatile unsigned long *)(GPIOA_BASE + 0x00))
#define GPIOA_AFRL         (*(volatile unsigned long *)(GPIOA_BASE + 0x20))

#define USART2_SR          (*(volatile unsigned long *)(USART2_BASE + 0x00))
#define USART2_DR          (*(volatile unsigned long *)(USART2_BASE + 0x04))
#define USART2_BRR         (*(volatile unsigned long *)(USART2_BASE + 0x08))
#define USART2_CR1         (*(volatile unsigned long *)(USART2_BASE + 0x0C))
#define USART2_CR2         (*(volatile unsigned long *)(USART2_BASE + 0x10))
#define USART2_CR3         (*(volatile unsigned long *)(USART2_BASE + 0x14))

#define GPIOA_ODR          (*(volatile uint32_t*)(GPIOA_BASE + 0x14))

struct myslot {
	uint32_t offset;
	struct usecboot_slot slot;
};

void *memcpy(void *dst, const void *src, size_t len);
void uart_puts(const char *str);

int prep(const struct usecboot_slot *slot)
{
	uint8_t hmac[32]={0};

	(void)usecboot_hmac_vrfy(slot, 0, slot->size, (uint8_t *)HMAC_KEY,
		                 sizeof(HMAC_KEY) - 1, hmac, sizeof(hmac));
	return USECBOOTERR_NONE;
}

int read(const struct usecboot_slot *slot, uint32_t start, void *data,
	 size_t len)
{
	const struct myslot *myslot = container_of(slot, struct myslot, slot);

	void *flash_ptr = (void *)(myslot->offset + start);

	memcpy(data, flash_ptr, len);
	return USECBOOTERR_NONE;
}

void boot(const struct usecboot_slot *slot, uint32_t ioff)
{
	const struct myslot *myslot = container_of(slot, struct myslot, slot);
	const uint32_t app_address = myslot->offset + ioff;
    	const uint32_t initial_sp = *(volatile uint32_t*)app_address;
	const uint32_t reset_handler = *(volatile uint32_t*)(app_address + 4);
	uint8_t hmac[32];

	(void)usecboot_hmac_calc(slot, 0, slot->size, (uint8_t *)HMAC_KEY,
		                 sizeof(HMAC_KEY) - 1, hmac, sizeof(hmac));

	__asm volatile ("dsb; isb");
	__asm volatile ("cpsid i");

	__asm volatile (
		"msr msp, %0\n"
		"bx %1\n"
		:
		: "r" (initial_sp), "r" (reset_handler)
    	);
}

void clean(const struct usecboot_slot *slot)
{
	(void)slot;
}

const struct usecboot_slotapi myapi = {
	.read = read,
	.prep = prep,
	.boot = boot,
	.clean = clean,
};

const struct myslot myslot[2] = {
	{
		.offset = IMAGE1_BASE,
		.slot.size = 2<<16,
		.slot.api = &myapi,
	},{
		.offset = IMAGE2_BASE,
		.slot.size = 2<<16,
		.slot.api = &myapi,
	},
};

const struct usecboot_slot *usecboot_get_slot(uint8_t idx)
{
	if (idx >= sizeof(myslot)/sizeof(myslot[0])) {
		return NULL;
	}

	return &myslot[idx].slot;
}

int usecboot_get_rejected_pubkey(uint32_t idx, uint8_t *pubkey, size_t len)
{
	(void)idx;
	(void)pubkey;
	(void)len;
	return -USECBOOTERR_ENOENT;
}

int usecboot_get_rootpkey(void *pkey, size_t len)
{
	const char *rootpkey = USECBOOT_ROOTPKEY;
	uint8_t *pk = (uint8_t *)pkey;

	if (len != sizeof(USECBOOT_ROOTPKEY) - 1) {
		return -USECBOOTERR_EINVAL;
	}

	memcpy(pk, rootpkey, len);
	return 0;
}

void uart_init(void);

int main(void)
{
	uart_init();
	usecboot_boot();
    	return 0;
}

/* provide a minimal memcpy and logging routine */
void *memcpy(void *dst, const void *src, size_t len)
{
	uint8_t *dst8 = (uint8_t *)dst;
	const uint8_t *src8 = (const uint8_t *)src;

	for (size_t i = 0; i < len; i++) {
		dst8[i] = src8[i];
	}

	return dst;
}

void uart_init(void) {
        // Enable GPIOA and USART2 clocks
    RCC_AHB1ENR |= (1 << 0);     // GPIOA clock enable
    RCC_APB1ENR |= (1 << 17);    // USART2 clock enable

    // PA2 = AF7 (USART2_TX), PA3 = AF7 (USART2_RX)
    GPIOA_MODER &= ~((3 << (2*2)) | (3 << (3*2))); // Clear mode
    GPIOA_MODER |=  ((2 << (2*2)) | (2 << (3*2))); // Alternate function mode

    GPIOA_AFRL &= ~((0xF << (2*4)) | (0xF << (3*4))); // Clear AF bits
    GPIOA_AFRL |=  ((7 << (2*4)) | (7 << (3*4)));     // Set AF7

    // 115200 baud @ 42 MHz APB1 clock --> BRR = 0x16D
    USART2_BRR = 0x08B;

    // Enable transmitter and receiver
    USART2_CR1 |= (1 << 3) | (1 << 2);

    // Enable USART
    USART2_CR1 |= (1 << 13);

    return 0;  // Success
}


void uart_putc(char c) {
    while (!(USART2_SR & (1 << 7)));  // Wait for TXE
    USART2_DR = c;
}

void uart_puts(const char *str) {
    while (*str) {
        uart_putc(*str++);
    }
}

void uart_puthex(uint32_t val) {
    const char hex_chars[] = "0123456789ABCDEF";

    uart_putc('0');
    uart_putc('x');

    for (int i = 28; i >= 0; i -= 4) {
        uart_putc(hex_chars[(val >> i) & 0xF]);
    }
}

void uart_putdec(uint32_t val) {
    char buffer[10];
    char *p = buffer + 9;
    *p = '\0';

    do {
        *--p = '0' + (val % 10);
        val /= 10;
    } while (val > 0);

    uart_puts(p);
}

void uart_vprintf(const char *fmt, va_list args)
{
	while (*fmt) {
		if (*fmt == '%') {
	    	fmt++;
	    	switch (*fmt) {
	        case 'd': {
        	        uint32_t val = va_arg(args, uint32_t);
                	uart_putdec(val);
                    	break;
                }
                case 'x': {
                    	uint32_t val = va_arg(args, uint32_t);
                    	uart_puthex(val);
			break;
                }
                case 's': {
			char *str = va_arg(args, char*);
			uart_puts(str);
			break;
                }
                case 'c': {
			char c = (char)va_arg(args, int);
                	uart_putc(c);
                	break;
                }
                default:
			uart_putc(*fmt);
            }
        } else {
        	uart_putc(*fmt);
        }
        fmt++;
    }
}

void uart_printf(const char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	uart_vprintf(fmt, args);
	va_end(args);
}

void usecboot_log(const char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	uart_vprintf(fmt, args);
	va_end(args);
}